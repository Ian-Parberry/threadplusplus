<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thread++: Thread++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Thread++
   </div>
   <div id="projectbrief">Client-Server Multithreading with C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Thread++ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>1. Introduction</h2>
<p >This code provides multithreaded support the C++ way for computation-heavy tasks such as backtracking or exhaustive search.</p>
<p ><a class="anchor" id="sec1point1"></a></p><h3>1.1 The Task Descriptor</h3>
<p >The task descriptor describes a task to be performed by a single thread. This code provides a base task descriptor <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> that includes a task identifier, a thread identifier, and a function to perform the task. You should derive your task descriptor from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a>.</p>
<p >Your task descriptor should implement a constructor for any task-related initialization and it should override function <a class="el" href="class_c_base_task.html#a7a45808d0356031760702d7376cf55bd" title="Perform this task.">CBaseTask::Perform()</a> with the code to perform your task. Be sure to provide space for the task results, if any, since the completed task descriptors will be used after thread termination to process the results. Each task descriptor you instantiate will automatically get a unique task identifier that can be read using <a class="el" href="class_c_base_task.html#ac1c06b41ce62a2b19356614b761d0fe9" title="Get task identifier.">CBaseTask::GetTaskId()</a>. This is maintained using a private static atomic member variable that is incremented and copied to a protected member variable by the <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> constructor. It is recommended that you do not interfere with this process. You are responsible for setting the thread identifier by calling <a class="el" href="class_c_base_task.html#a47be69a4a75e9640997c9eff20d8ad08" title="Set thread identifier.">CBaseTask::SetThreadId()</a> when this task descriptor is assigned to a thread. The thread identifier can be read later by calling <a class="el" href="class_c_base_task.html#a1c134cd1977a763485f871fe1019e6a8" title="Get thread identifier.">CBaseTask::GetThreadId()</a>. The task and thread identifiers are provided primarily for debugging purposes and do not impose a significant load on time or memory requirements.</p>
<p ><a class="anchor" id="sec1point2"></a></p><h3>1.2 The Thread-Safe Queue</h3>
<p ><a class="anchor" id="fig1"></a></p><div class="image">
<img src="queue.png" alt="" width="20%"/>
<div class="caption">
Fig. 1: The thread-safe queue allows simultaneous requests to insert and delete from concurrent threads, but only one can proceeed at a time.</div></div>
<p >The thread-safe queue <a class="el" href="class_c_thread_safe_queue.html" title="Thread safe queue.">CThreadSafeQueue</a> maintains a private <code>std::queue</code> of task descriptors for communicating task descriptors between the threads and the thread manager. It uses an <code>std::mutex</code> for safety. The mutex is locked whenever a thread is in the process of inserting or deleting a task request from the queue. All other threads are forced to wait until the process is complete and the thread unlocks the mutex. Since inserting to and deleting from an <code>std::queue</code> is fairly efficient, this should not be a significant fraction of time assuming that this code is to be used for computation-heavy tasks such as backtracking or exhaustive search. As shown in <a class="el" href="index.html#fig1">Fig. 1</a>, multiple insert/delete requests from concurrent threads can come into the thread-safe queue simultaneously (the colored arrows at the bottom), but the mutex allows only one to proceed at a time (in this case the blue arrow).</p>
<p ><a class="el" href="class_c_thread_safe_queue.html" title="Thread safe queue.">CThreadSafeQueue</a> is a templated class which should be instantiated using your task descriptor class derived from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> (see <a class="el" href="index.html#sec1point1">Section 1.1</a>).</p>
<p ><a class="anchor" id="sec1point3"></a></p><h3>1.3 The Common Variables Class</h3>
<p >The common variables class <a class="el" href="class_c_common.html" title="Common.">CCommon</a> contains variables to be shared between threads and the thread manager without the need for providing them as parameters. These consist of the request queue, a thread-safe queue of pointers to uncompleted task descriptors (see <a class="el" href="index.html#sec1point2">Section 1.2</a>); the result queue, a thread-safe queue of pointers to completed task descriptors (see also <a class="el" href="index.html#sec1point2">Section 1.2</a>); and a Boolean value <a class="el" href="class_c_common.html#a8374f04015b722848944a92365959e39" title="Force exit flag.">CCommon::m_bForceExit</a> to be set if and when you want all threads to terminate without completing any more tasks.</p>
<p ><a class="el" href="class_c_common.html" title="Common.">CCommon</a> is a templated class which should be instantiated using your task descriptor class derived from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> (see <a class="el" href="index.html#sec1point1">Section 1.1</a>).</p>
<p ><a class="anchor" id="sec1point4"></a></p><h3>1.4 The Thread Manager</h3>
<p >The thread manager takes care of inserting task requests into the request queue, initiating the threads, waiting until all threads terminate, and processing the completed task requests from the result queue. This code provides a base thread manager <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a>, a templated class derived from <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec1point3">Section 1.3</a>). You should derive your templated thread manager from <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a> using your task descriptor class derived from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> (see <a class="el" href="index.html#sec1point1">Section 1.1</a>) to instantiate the template. Your task manager should overload function <a class="el" href="class_c_base_thread_manager.html#a5fbeaa887405606ed753184174059e2f" title="Process the result of a task.">CBaseThreadManager::ProcessTask()</a> to process the results from a completed task descriptor.</p>
<p >Your code should call <a class="el" href="class_c_base_thread_manager.html#af523b683888b8919eeebec341c65e820" title="Insert a task.">CBaseThreadManager::Insert()</a> in a loop that creates new task descriptors (see <a class="el" href="index.html#sec1point1">Section 1.1</a>). <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a> will insert these task requests into the thread-safe request queue (see <a class="el" href="index.html#sec1point2">Section 1.2</a>) that it inherits from <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec1point3">Section 1.3</a>). This process is illustrated in <a class="el" href="index.html#fig2">Fig. 2</a>.</p>
<p ><a class="anchor" id="fig2"></a></p><div class="image">
<img src="phase1.png" alt="" width="35%"/>
<div class="caption">
Fig. 2: The thread manager sequentially creates and inserts task descriptors into the request queue.</div></div>
<p >It should then call <a class="el" href="class_c_base_thread_manager.html#acb6ef83b1e6215df955a717b7b61f179" title="Spawn threads.">CBaseThreadManager::Spawn()</a> to spawn the threads, which delete task descriptors from the thread-safe request queue, completes the tasks, and inserts completed task descriptors into the thread-safe result queue. This process will be described in more detail in <a class="el" href="index.html#sec1point5">Section 1.5</a>. This process is illustrated in <a class="el" href="index.html#fig3">Fig. 3</a>.</p>
<p ><a class="anchor" id="fig3"></a></p><div class="image">
<img src="phase2.png" alt="" width="35%"/>
<div class="caption">
Fig. 3: Threads perform the tasks from the request queue and transfer the completed task descriptors into the result queue.</div></div>
<p >Your code should then call <a class="el" href="class_c_base_thread_manager.html#a05a5a4d610762ac9a0e6817327ede425" title="Wait for threads to finish all tasks.">CBaseThreadManager::Wait()</a> to wait until all threads terminate. After this function returns, your code should call <a class="el" href="class_c_base_thread_manager.html#a0dfb5636ec4d410e879473b485e37a16" title="Process results of all tasks.">CBaseThreadManager::Process()</a> to process the completed task descriptors. <a class="el" href="class_c_base_thread_manager.html#a0dfb5636ec4d410e879473b485e37a16" title="Process results of all tasks.">CBaseThreadManager::Process()</a> will call your overloaded virtual <a class="el" href="class_c_base_thread_manager.html#a5fbeaa887405606ed753184174059e2f" title="Process the result of a task.">CBaseThreadManager::ProcessTask()</a> which, if you have done your job correctly, will report the results, ideally to the console and to a file (it's up to you). This is executed sequentially becaise it is assumed that the bulk of the computation has been performed in parallel by the concurrent threads and all that remains is to tally the results. This process is illustrated in <a class="el" href="index.html#fig4">Fig. 4</a>.</p>
<p ><a class="anchor" id="fig4"></a></p><div class="image">
<img src="phase3.png" alt="" width="35%"/>
<div class="caption">
Fig. 4: The thread manager sequentially processes the completed task descriptors from the result queue.</div></div>
<p ><a class="anchor" id="sec1point5"></a></p><h3>1.5 The Threads</h3>
<p >The thread class <a class="el" href="class_c_thread.html" title="The thread class.">CThread</a> consists of a loop in which a task descriptor (see <a class="el" href="index.html#sec1point1">Section 1.1</a>) is deleted from the thread-safe request queue (see <a class="el" href="index.html#sec1point2">Section 1.2</a>) inherited from <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec1point3">Section 1.3</a>), the task described in the task descriptor is performed by calling your task descriptor's function overriding <a class="el" href="class_c_base_task.html#a7a45808d0356031760702d7376cf55bd" title="Perform this task.">CBaseTask::Perform()</a>, and the completed task descriptor is inserted into the thread-safe result queue(see <a class="el" href="index.html#sec1point2">Section 1.2</a>), also inherited from <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec1point3">Section 1.3</a>). The loop exits when either the request queue is empty (<a class="el" href="class_c_thread_safe_queue.html#ac00956af0cc3398b95f106099ed2ab5b" title="Delete task from head.">CThreadSafeQueue::Delete()</a> returns <code>false</code>) or the shared Boolean variable <a class="el" href="class_c_common.html#a8374f04015b722848944a92365959e39" title="Force exit flag.">CCommon::m_bForceExit</a> is set to <code>true</code>, at which time the thread terminates.</p>
<p ><a class="anchor" id="sec1point6"></a></p><h3>1.6 The Timer</h3>
<p >Assuming that you will be using this code for backtracking or exhaustive search, you will also be interested in measuring the CPU time used over the whole computation, summed over all of the threads, and the elapsed time. The elapsed time should ideally be the CPU time divided by the number of threads, but this assumes that you have made good decisions about how your tasks should be parallelized.</p>
<p >The timer class <a class="el" href="class_c_timer.html" title="Timer for elapsed time and CPU time.">CTimer</a> has a start function <a class="el" href="class_c_timer.html#a4c95a1f25b3ef73436d4876260a2e013" title="Start timing.">CTimer::Start()</a> that should be called from your code when you want to start measuring time, leaving the decision over whether to measure initialization time completely up to you. The main functions of interest are <a class="el" href="class_c_timer.html#af24be1dc3384bebb3c0f28702bc63e36" title="Get current time and date.">CTimer::GetCurrentDateAndTime()</a> which returns the current date and time as an <code>std::string</code>, and <a class="el" href="class_c_timer.html#aae0fc25f21522d40a80fcf1417b64212" title="Get elapsed time in seconds.">CTimer::GetElapsedTime()</a> and <a class="el" href="class_c_timer.html#ad68def9a42e484e50f9136fea7ac8436" title="Get CPU time in seconds.">CTimer::GetCPUTime()</a> which return, respectively, the elapsed and CPU time as pretty-printed <code>std::string</code>s. It's up to you to instantiate an instance of <a class="el" href="class_c_timer.html" title="Timer for elapsed time and CPU time.">CTimer</a> in your code, make the appropriate function calls, and output the resulting strings to the console or to a file using, for example, <code>std::iostream</code>, <code>std::fstream</code>, or <code>stdio</code>.</p>
<p ><a class="el" href="class_c_timer.html" title="Timer for elapsed time and CPU time.">CTimer</a> uses <code>std::chrono</code> to measure elapsed time, but since there is (alas!) a dearth of platform-independent code to measure CPU time, we are forced to use <code>#ifdef</code>s, some code cribbed from a Microsoft demo to sum CPU time over multiple threads under Windows and Visual Studio, and <code>clock()</code> from <code>time.h</code> under <code>*NIX</code> and <code>g++</code>.</p>
<h2>2. Compiling the Code</h2>
<h3>For Windows Users:</h3>
<p >A Visual Studio solution file <code>threadplusplus.sln</code> has been provided in the root folder. It has been tested with Visual Studio 2019 Community under Windows 10.</p>
<p ><a class="anchor" id="sec3"></a></p><h2>3. Drilling Down Into the Code</h2>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 24 2022 16:26:33 for Thread++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
