<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thread++: Thread++</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Thread++
   </div>
   <div id="projectbrief">Client-Server Multithreading with C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Thread++ </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>1. Introduction</h2>
<p >This code provides object-oriented multi-threading support for computation-heavy tasks such as backtracking or exhaustive search. In order to take advantage of the potential speedup offered by multi-threading, your computation must be capable of being broken up into parts that can be performed independently in parallel.</p>
<p >The remainder of this page is divided into four sections. <a class="el" href="index.html#sec2">Section 2</a> describes how to compile the code, which is probably the first thing you should do. <a class="el" href="index.html#sec3">Section 3</a> drills down into the code, which is important to read before you go about incorporating it into your own project. <a class="el" href="index.html#sec4">Section 4</a> summarizes what this code provides and what you must provide, just to make sure that we are both on the same page. <a class="el" href="index.html#sec5">Section 5</a> describes what you need to do to use this code in your own project.</p>
<p ><a class="anchor" id="sec2"></a></p><h2>2. Compiling the Code</h2>
<p ><a class="anchor" id="sec2point1"></a></p><h3>2.1 Windows and Visual Studio</h3>
<p >A Visual Studio solution file <code>threadplusplus.sln</code> has been provided in the root folder. It has been tested with Visual Studio 2019 Community under Windows 10 in both <code>Debug</code> and <code>Release</code> configurations on the <code>x64</code> and <code>x86</code> platforms. It consists of two projects, <code>threadplusplus</code> and <code>Test</code>. Project <code>threadplusplus</code> compiles into a library file <code>threadplusplus.lib</code>. Project <code>Test</code> compiles into a test executable <code>Test.exe</code> described in more detail <a href="..\html2\index.html">in this documentation</a>.</p>
<p ><a class="anchor" id="sec2point2"></a></p><h3>2.2 *NIX and g++</h3>
<p >There is a <code>makefile</code> for the <code>threadplusplus</code> library in directory <code>Src</code>. From the root folder (the one with <code>threadplusplus.sln</code>), type <code>cd Src</code> followed by <code>make all</code>, then <code>make cleanup</code>. You should now see the library file <code>threadplusplus.a</code>.</p>
<p >There is a <code>makefile</code> for the <code>Test</code> program in directory <code>Test</code>. From the root folder (the one with <code>threadplusplus.sln</code>), type <code>cd Test</code> followed by <code>make all</code>. You should now see the executable file <code>Test</code>. Run it by typing <code>./Test</code>.</p>
<p ><a class="anchor" id="sec3"></a></p><h2>3. Drilling Down Into the Code</h2>
<p >In order to take full advantage of the potential speedup offered by multi-threading, your computation must be broken up into a reasonable number of parts (ideally between 10 and 1000) that can be performed independently in parallel. We will call these <em>tasks</em>. Each task is described in a <em>task</em> <em>descriptor</em> that includes the data that specifies the task, the code for performing the task, and space for its result (see <a class="el" href="index.html#sec3point1">Section 3.1</a>).</p>
<p >Newly created task descriptors are inserted into a thread-safe (see <a class="el" href="index.html#sec3point2">Section 3.2</a>) <em>request</em> <em>queue</em> from which the threads will take them, perform the task described, and insert the completed task descriptor with its result into a thread-safe <em>result</em> <em>queue</em>. The request queue and the result queue are shared between objects using a monostate class <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec3point3">Section 3.3</a>). The computation as a whole is managed by a <em>thread</em> <em>manager</em> (see <a class="el" href="index.html#sec3point4">Section 3.4</a>) which creates and inserts task descriptors into the request queue, initiates the threads (see <a class="el" href="index.html#sec3point5">Section 3.5</a>), waits until all threads terminate, then processes the completed task requests from the result queue.</p>
<p >A timer class is also provided to enable you to easily measure and report elapsed time and total CPU time (see <a class="el" href="index.html#sec3point6">Section 3.6</a>).</p>
<p ><a class="anchor" id="sec3point1"></a></p><h3>3.1 The Task Descriptor</h3>
<p >The task descriptor describes a task to be performed by a single thread. This code provides a base task descriptor <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> that includes a task identifier, a thread identifier, and a function to perform the task. You should derive your task descriptor from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a>. Your task descriptor should implement a constructor for any task-related initialization and it should override function <a class="el" href="class_c_base_task.html#a7a45808d0356031760702d7376cf55bd" title="Perform this task.">CBaseTask::Perform()</a> with the code to perform your task. Be sure to provide space for the task results, if any, since the completed task descriptors will be used after thread termination to process the results.</p>
<p >Each task descriptor you instantiate will automatically get a unique task identifier that can be read using <a class="el" href="class_c_base_task.html#ac1c06b41ce62a2b19356614b761d0fe9" title="Get task identifier.">CBaseTask::GetTaskId()</a>. This is maintained using a private static atomic member variable that is incremented and copied to a protected member variable by the <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> constructor. It is recommended that you do not interfere with this process. You are responsible for setting the thread identifier by calling <a class="el" href="class_c_base_task.html#a47be69a4a75e9640997c9eff20d8ad08" title="Set thread identifier.">CBaseTask::SetThreadId()</a> when this task descriptor is assigned to a thread. The thread identifier can be read later by calling <a class="el" href="class_c_base_task.html#a1c134cd1977a763485f871fe1019e6a8" title="Get thread identifier.">CBaseTask::GetThreadId()</a>. The task and thread identifiers are provided primarily for debugging purposes and do not impose a significant load on time or memory requirements.</p>
<p ><a class="anchor" id="sec3point2"></a></p><h3>3.2 The Thread-Safe Queue</h3>
<p ><a class="anchor" id="fig1"></a></p><div class="image">
<img src="queue.png" alt="" width="20%"/>
<div class="caption">
Fig. 1: The thread-safe queue allows simultaneous requests to insert and delete from concurrent threads, but only one can proceeed at a time.</div></div>
<p >The thread-safe queue <a class="el" href="class_c_thread_safe_queue.html" title="Thread safe queue.">CThreadSafeQueue</a> maintains a private <code>std::queue</code> of task descriptors for communicating task descriptors between the threads and the thread manager. It uses an <code>std::mutex</code> for safety. The mutex is locked whenever a thread is in the process of inserting or deleting a task request from the queue. All other threads are forced to wait until the process is complete and the thread unlocks the mutex. Since inserting to and deleting from an <code>std::queue</code> is fairly efficient, this should not be a significant fraction of time assuming that this code is to be used for computation-heavy tasks such as backtracking or exhaustive search. As shown in <a class="el" href="index.html#fig1">Fig. 1</a>, multiple insert/delete requests from concurrent threads can come into the thread-safe queue simultaneously (the colored arrows at the bottom), but the mutex allows only one to proceed at a time (in this case the blue arrow).</p>
<p ><a class="el" href="class_c_thread_safe_queue.html" title="Thread safe queue.">CThreadSafeQueue</a> is a templated class which should be instantiated using your task descriptor class derived from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> (see <a class="el" href="index.html#sec3point1">Section 3.1</a>).</p>
<p ><a class="anchor" id="sec3point3"></a></p><h3>3.3 The Common Variables Class</h3>
<p >The common variables class <a class="el" href="class_c_common.html" title="Common.">CCommon</a> contains variables to be shared between the threads and the thread manager. It is a <em>monostate</em>, that is, is a class that encapsulates a single instance of shared data without the need for global variables, extended parameter lists, or local copies of the data. The monostate is also called the <em>Borg</em> <em>Idiom</em> in the Python community.</p>
<p ><a class="el" href="class_c_common.html" title="Common.">CCommon</a> consists of the request queue, a thread-safe queue of pointers to uncompleted task descriptors (see <a class="el" href="index.html#sec3point2">Section 3.2</a>); the result queue, a thread-safe queue of pointers to completed task descriptors (see also <a class="el" href="index.html#sec3point2">Section 3.2</a>); and a Boolean value <a class="el" href="class_c_common.html#a8374f04015b722848944a92365959e39" title="Force exit flag.">CCommon::m_bForceExit</a> to be set if and when the computation is to be aborted prematurely.</p>
<p ><a class="el" href="class_c_common.html" title="Common.">CCommon</a> is a templated class which should be instantiated using your task descriptor class derived from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> (see <a class="el" href="index.html#sec3point1">Section 3.1</a>).</p>
<p ><a class="anchor" id="sec3point4"></a></p><h3>3.4 The Thread Manager</h3>
<p >The thread manager takes care of inserting task requests into the request queue, initiating the threads, waiting until all threads terminate, and processing the completed task requests from the result queue. This code provides a base thread manager <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a>, a templated class derived from <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec3point3">Section 3.3</a>). You should derive your templated thread manager from <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a> using your task descriptor class derived from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> (see <a class="el" href="index.html#sec3point1">Section 3.1</a>) to instantiate the template. Your task manager should overload function <a class="el" href="class_c_base_thread_manager.html#a5fbeaa887405606ed753184174059e2f" title="Process the result of a task.">CBaseThreadManager::ProcessTask()</a> to process the results from a completed task descriptor.</p>
<p >Your code should call <a class="el" href="class_c_base_thread_manager.html#af523b683888b8919eeebec341c65e820" title="Insert a task.">CBaseThreadManager::Insert()</a> in a loop that creates new task descriptors (see <a class="el" href="index.html#sec3point1">Section 3.1</a>). <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a> will insert these task requests into the thread-safe request queue (see <a class="el" href="index.html#sec3point2">Section 3.2</a>) that it inherits from <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec3point3">Section 3.3</a>). This process is illustrated in <a class="el" href="index.html#fig2">Fig. 2</a>.</p>
<p ><a class="anchor" id="fig2"></a></p><div class="image">
<img src="phase1.png" alt="" width="35%"/>
<div class="caption">
Fig. 2: The thread manager sequentially creates and inserts task descriptors into the request queue.</div></div>
<p >It should then call <a class="el" href="class_c_base_thread_manager.html#acb6ef83b1e6215df955a717b7b61f179" title="Spawn threads.">CBaseThreadManager::Spawn()</a> to spawn the threads, which delete task descriptors from the thread-safe request queue, completes the tasks, and inserts completed task descriptors into the thread-safe result queue. This process will be described in more detail in <a class="el" href="index.html#sec3point5">Section 3.5</a>. This process is illustrated in <a class="el" href="index.html#fig3">Fig. 3</a>.</p>
<p ><a class="anchor" id="fig3"></a></p><div class="image">
<img src="phase2.png" alt="" width="35%"/>
<div class="caption">
Fig. 3: Threads perform the tasks from the request queue and transfer the completed task descriptors into the result queue.</div></div>
<p >Your code should then call <a class="el" href="class_c_base_thread_manager.html#a05a5a4d610762ac9a0e6817327ede425" title="Wait for threads to finish all tasks.">CBaseThreadManager::Wait()</a> to wait until all threads terminate. After this function returns, your code should call <a class="el" href="class_c_base_thread_manager.html#a0dfb5636ec4d410e879473b485e37a16" title="Process results of all tasks.">CBaseThreadManager::Process()</a> to process the completed task descriptors. <a class="el" href="class_c_base_thread_manager.html#a0dfb5636ec4d410e879473b485e37a16" title="Process results of all tasks.">CBaseThreadManager::Process()</a> will call your overloaded virtual <a class="el" href="class_c_base_thread_manager.html#a5fbeaa887405606ed753184174059e2f" title="Process the result of a task.">CBaseThreadManager::ProcessTask()</a> which, if you have done your job correctly, will report the results, ideally to the console and to a file (it's up to you). This is executed sequentially becaise it is assumed that the bulk of the computation has been performed in parallel by the concurrent threads and all that remains is to tally the results. This process is illustrated in <a class="el" href="index.html#fig4">Fig. 4</a>.</p>
<p ><a class="anchor" id="fig4"></a></p><div class="image">
<img src="phase3.png" alt="" width="35%"/>
<div class="caption">
Fig. 4: The thread manager sequentially processes the completed task descriptors from the result queue.</div></div>
<p ><a class="anchor" id="sec3point5"></a></p><h3>3.5 The Threads</h3>
<p >The thread class <a class="el" href="class_c_thread.html" title="The thread class.">CThread</a> provides a constructor that assigns a thread identifier and an implementation of <code>operator()</code> containing the code to be executed by the thread. This code consists of a loop whose body consists of the following:</p>
<ol>
<li>
<p class="startli">A pointer to a task descriptor (see <a class="el" href="index.html#sec3point1">Section 3.1</a>) is deleted from the thread-safe request queue (see <a class="el" href="index.html#sec3point2">Section 3.2</a>) inherited from <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec3point3">Section 3.3</a>). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The task described in the task descriptor is performed by calling the task descriptor's function overriding <a class="el" href="class_c_base_task.html#a7a45808d0356031760702d7376cf55bd" title="Perform this task.">CBaseTask::Perform()</a>. </p>
<p class="endli"></p>
</li>
<li>
A pointer to the completed task descriptor is inserted into the thread-safe result queue (see <a class="el" href="index.html#sec3point2">Section 3.2</a>), also inherited from <a class="el" href="class_c_common.html" title="Common.">CCommon</a> (see <a class="el" href="index.html#sec3point3">Section 3.3</a>).  </li>
</ol>
<p >The loop exits when either the request queue is empty (<a class="el" href="class_c_thread_safe_queue.html#ac00956af0cc3398b95f106099ed2ab5b" title="Delete task from head.">CThreadSafeQueue::Delete()</a> returns <code>false</code>) or the shared Boolean variable <a class="el" href="class_c_common.html#a8374f04015b722848944a92365959e39" title="Force exit flag.">CCommon::m_bForceExit</a> is set to <code>true</code>, at which time the thread terminates.</p>
<p ><a class="anchor" id="sec3point6"></a></p><h3>3.6 The Timer</h3>
<p >Assuming that you will be using this code for backtracking or exhaustive search, you will also be interested in measuring the CPU time used over the whole computation, summed over all of the threads, and the elapsed time. The elapsed time should ideally be the CPU time divided by the number of threads, but this assumes that you have made good decisions about how your tasks should be parallelized.</p>
<p >The timer class <a class="el" href="class_c_timer.html" title="Timer for elapsed time and CPU time.">CTimer</a> has a start function <a class="el" href="class_c_timer.html#a4c95a1f25b3ef73436d4876260a2e013" title="Start timing.">CTimer::Start()</a> that should be called from your code when you want to start measuring time, leaving the decision over whether to measure initialization time completely up to you. The main functions of interest are CTimer::GetCurrentDateAndTime() which returns the current date and time as an <code>std::string</code>, and <a class="el" href="class_c_timer.html#aae0fc25f21522d40a80fcf1417b64212" title="Get elapsed time in seconds.">CTimer::GetElapsedTime()</a> and <a class="el" href="class_c_timer.html#ad68def9a42e484e50f9136fea7ac8436" title="Get CPU time in seconds.">CTimer::GetCPUTime()</a> which return, respectively, the elapsed and CPU time as pretty-printed <code>std::string</code>s. It's up to you to instantiate an instance of <a class="el" href="class_c_timer.html" title="Timer for elapsed time and CPU time.">CTimer</a> in your code, make the appropriate function calls, and output the resulting strings to the console or to a file using, for example, <code>std::iostream</code>, <code>std::fstream</code>, or <code>stdio</code>.</p>
<p ><a class="el" href="class_c_timer.html" title="Timer for elapsed time and CPU time.">CTimer</a> uses <code>std::chrono</code> to measure elapsed time, but since there is (alas!) a dearth of platform-independent code to measure CPU time, we are forced to use <code>#ifdef</code>s, some code cribbed from a Microsoft demo to sum CPU time over multiple threads under Windows and Visual Studio, and <code>clock()</code> from <code>time.h</code> under <code>*NIX</code> and <code>g++</code>.</p>
<p ><a class="anchor" id="sec4"></a></p><h2>4. Summary</h2>
<p >In summary, you need to know <a class="el" href="index.html#sec4point1">what this code provides</a> and <a class="el" href="index.html#sec4point2">what you must provide</a> before working with this code.</p>
<p ><a class="anchor" id="sec4point1"></a></p><h3>4.1 What This Code Provides</h3>
<ol type="1">
<li>A base task descriptor <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a>.</li>
<li>A base thread manager <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a>.</li>
<li>A thread class <a class="el" href="class_c_thread.html" title="The thread class.">CThread</a>.</li>
<li>A thread-safe queue <a class="el" href="class_c_thread_safe_queue.html" title="Thread safe queue.">CThreadSafeQueue</a>.</li>
<li>A timer class <a class="el" href="class_c_timer.html" title="Timer for elapsed time and CPU time.">CTimer</a>.</li>
</ol>
<p ><a class="anchor" id="sec4point2"></a></p><h3>4.2 What You Must Provide</h3>
<ol type="1">
<li>A task descriptor <code>CTask</code> derived from <a class="el" href="class_c_base_task.html" title="Base task descriptor.">CBaseTask</a> with member variables that specify the task to be performed and a member function <code>CTask::Perform()</code> to override <a class="el" href="class_c_base_task.html#a7a45808d0356031760702d7376cf55bd" title="Perform this task.">CBaseTask::Perform()</a> containing code to perform your task as specified in its member variables.</li>
<li>A thread manager <code>CThreadManager</code> derived from <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a> <code>&lt;CTask&gt;</code>. It must contain, in addition to a constructor that calls the <a class="el" href="class_c_base_thread_manager.html" title="The base thread manager.">CBaseThreadManager</a> constructor, a function <code>CThreadManager::ProcessTask(CTask*)</code> that overrides <code>CBaseThreadManager::ProcessTask(CBaseTask*)</code> with code that processes the results of your task pointed to by its single parameter.</li>
<li>A <code>main()</code> that instantiates an instance of <code>CThreadManager</code> and an instance of <a class="el" href="class_c_timer.html" title="Timer for elapsed time and CPU time.">CTimer</a> (if required). It then creates the required instances of <code>CTask</code> and calls the thread manager's <code>Insert()</code> function to insert them into the request queue. Next, it starts the timer (if required) by calling <code><a class="el" href="class_c_timer.html#a4c95a1f25b3ef73436d4876260a2e013" title="Start timing.">CTimer::Start()</a></code>. This line of code may be omitted if initialization is to be included in the time reported. It then calls the thread manager's <code>Spawn()</code> function to spawn the threads and the thread manager's <code>Wait()</code> function to wait for the threads to terminate. When that function returns, the result queue should contain processed task descriptors. Now <code>main()</code> can report CPU time and elapsed time (if required), and finally call the thread managers <code>Process()</code> function to process and report the results of the computation.</li>
</ol>
<p >A simple test executable is provided as part of this project (see <a class="el" href="index.html#sec2">Section 2</a>).</p>
<p ><a class="anchor" id="sec5"></a></p><h2>5. Using This Code</h2>
<p ><a class="anchor" id="sec5point1"></a></p><h3>5.1 Windows and Visual Studio</h3>
<ol>
<li>
<p class="startli">Compile this code in whatever configurations and platforms you require (see <a class="el" href="index.html#sec2point1">Section 2.1</a>). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">It is recommended that you create a Windows environment variable <code>THREADPLUSPLUS_DIR</code> and set it to the name of the folder that contains <code>threadplusplus.sln</code>, terminating it with a backslash character <code>\</code> (see <a class="el" href="index.html#fig5">Fig. 5</a>). Make sure that you shut down and restart all instances of Visual Studio before you proceed, otherwise Visual Studio will not see your environment variable and you will get a "header
file not found" and/or "library file not found" error message when you try to compile and link your code. </p>
<p class="interli"><a class="anchor" id="fig5"></a></p><div class="image">
<img src="env.png" alt="" width="60%"/>
<div class="caption">
Fig. 5: Creating the environment variable THREADPLUSPLUS_DIR.</div></div>
<p class="endli"></p>
</li>
<li>
<p class="startli">Having done the above, create your own Visual Studio solution and project, then in your project properties with your required configuration (ideally <code>All Configurations</code>) and platform (ideally <code>All Platforms</code>), do the following three things under <code>Configuration Properties</code>:</p>
<ol style="list-style-type: lower-alpha">
<li>
<p class="startli">In <code>VC++ Directories</code>, add <code>$(THREADPLUSPLUS_DIR)Src</code> to <code>Include Directories</code> (see <a class="el" href="index.html#fig6">Fig. 6</a>). </p>
<p class="interli"><a class="anchor" id="fig6"></a></p><div class="image">
<img src="dir.png" alt="" width="80%"/>
<div class="caption">
Fig. 6: Adding the Include and Library Directories in Visual Studio.</div></div>
<p class="endli"></p>
</li>
<li>
<p class="startli">On the same page, add <code>$(THREADPLUSPLUS_DIR)$(Platform)\$(Configuration)</code> to <code>Library Directories</code> (see <a class="el" href="index.html#fig6">Fig. 6</a>). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">In <code>Linker\Input</code>, add <code>threadplusplus.lib</code> to <code>Additional Dependencies</code> (see <a class="el" href="index.html#fig7">Fig. 7</a>). </p>
<p class="endli"><a class="anchor" id="fig7"></a></p><div class="image">
<img src="lib.png" alt="" width="80%"/>
<div class="caption">
Fig. 7: Adding threadplusplus.lib in Visual Studio.</div></div>
 </li>
</ol>
<p class="endli"></p>
</li>
<li>
Remember to <code>#include</code> <a class="el" href="_base_task_8h.html" title="Header for the class CBaseTask.">BaseTask.h</a>, <a class="el" href="_base_thread_manager_8h.html" title="Header and code for the class CBaseThreadManager.">BaseThreadManager.h</a>, and <code><a class="el" href="_timer_8h.html" title="Header for the class CTimer.">Timer.h</a></code> wherever appropriate in your code.  </li>
</ol>
<p ><a class="anchor" id="sec5point2"></a></p><h3>5.2 *NIX and g++</h3>
<ol>
<li>
<p class="startli">Compile this code (see <a class="el" href="index.html#sec2point2">Section 2.2</a>). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Copy the <code>makefile</code> from the <code>Test</code> directory (see <a class="el" href="index.html#sec2">Section 2</a>) to your source code directory. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Edit the copy of the <code>makefile</code> in your source code directory. </p>
<ol style="list-style-type: lower-alpha">
<li>
<p class="startli">Change line 1 to set the <code>SRC</code> variable to your source and header files. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Change line 2 to set the <code>EXE</code> variable to your executable file name. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Change line 3 to set the <code>INC</code> variable to the relative path of the <code>Src</code> folder in this project (currently <code>../Src</code>). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Change line 4 to set the <code>LIB</code> variable to the relative path of the <code>Src</code> folder in this project followed by <code>threadplusplus.a</code> (currently <code>../Src/threadplusplus.a</code>). </p>
<p class="endli"></p>
</li>
<li>
Save the file.  </li>
</ol>
<p class="endli"></p>
</li>
<li>
Type <code>make all</code> to create your executable file.  </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 1 2022 12:15:04 for Thread++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
